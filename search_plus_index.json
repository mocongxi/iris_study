{"./":{"url":"./","title":"简介","keywords":"","body":"学习iris笔记 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"GET、POST等请求及数据处理.html":{"url":"GET、POST等请求及数据处理.html","title":"GET、POST等请求及数据处理","keywords":"","body":"GET、POST等请求及数据处理 GET请求 app := iris.New() app.Handle(\"GET\", \"/hello\", func(context context.Context) { context.HTML(\" Hello world. \") }) app.Get(\"/hello\", func(context context.Context) { context.HTML(\" Hello world. \") }) app.Handle(\"GET\", \"/string\", func(context context.Context) { context.WriteString(\" This is get request \") }) 处理GET请求，请求的url为:/hello ,打印log app.Logger().Info(path) POST 请求 app.Post(\"/user/info\", func(context context.Context) { context.WriteString(\" User Info is Post Request \") }) app.Handle(\"POST\", \"/user/info\", func(context context.Context) { context.WriteString(\" User Info is Post Request , Deal is in handle func \") }) 读取GET请求，并接受参数 //http://localhost:8080/userinfo?username=mjt&password=123 app.Get(\"/userinfo\", func(context context.Context) { path := context.Path() app.Logger().Info(path) userName := context.URLParam(\"username\") app.Logger().Info(userName) pwd := context.URLParam(\"password\") app.Logger().Info(pwd) context.WriteString(\"userName:\" + userName + \" password:\" + pwd) }) 读取POST请求，form表单的字段数据 app.Post(\"/postLogin\", func(context context.Context) { path := context.Path() app.Logger().Info(path) name := context.PostValue(\"name\") pwd := context.PostValue(\"pwd\") context.WriteString(\"userName:\" + name + \" password:\" + pwd) }) 处理Post请求，Json格式数据 首先定义一个结构体来接纳参数 type Person struct { Name string `json:\"name\"` Age int `json:\"age\"` } POST核心代码 context.ReadJSON(&person) /** *Postman工具选择[{\"key\":\"Content-Type\",\"value\":\"application/json\",\"description\":\"\"}] *请求内容：{\"name\": \"davie\",\"age\": 28} */ app.Post(\"/postJson\", func(context context.Context) { //1.path path := context.Path() app.Logger().Info(\"请求URL：\", path) //2.Json数据解析 var person Person //context.ReadJSON() if err := context.ReadJSON(&person); err != nil { panic(err.Error()) } //输出：Received: main.Person{Name:\"davie\", Age:28} context.Writef(\"Received: %#+v\\n\", person) }) 处理Post请求 Xml格式数据 首先定义一个结构体来接纳参数 type Student struct { //XMLName xml.Name `xml:\"student\"` StuName string `xml:\"stu_name\"` StuAge int `xml:\"stu_age\"` } POST核心代码 context.ReadXML(&student) /** * 请求配置：Content-Type到application/xml（可选但最好设置） * 请求内容： * * * davie * 28 * * */ app.Post(\"/postXml\", func(context context.Context) { //1.Path path := context.Path() app.Logger().Info(\"请求URL：\", path) //2.XML数据解析 var student Student if err := context.ReadXML(&student); err != nil { panic(err.Error()) } //输出： context.Writef(\"Received：%#+v\\n\", student) }) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"请求处理的数据格式返回.html":{"url":"请求处理的数据格式返回.html","title":"请求处理的数据格式返回","keywords":"","body":"请求处理的数据格式返回 请求处理的数据格式返回 在本节课程中，我们已经学习了如何对不同类型的请求进行处理以及如何获取请求所携带的数据，当后台接收到请求后，将会对请求进行处理，处理完毕后将数据返回给请求的客户端。接下来，我们看一看如何将数据进行返回，以及都有哪些形式。 在进行请求处理时，处理方法func有一个参数context。Context是用于处理请求的上下文环境变量，用于处理http请求及相关数据返回。iris框架支持多种数据格式的返回，此处我们学习掌握返回string、json、xml以及html格式的数据。 返回string类型数据 context.WriteString(\"hello world\") 返回json格式的数据 context.JSON(iris.Map{\"message\": \"hello word\", \"requestCode\": 200}) 返回xml格式的数据 context.XML(Person{Name: \"Davie\", Age: 18}) 返回html格式数据 context.HTML(\" Davie, 12 \") console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"路由.html":{"url":"路由.html","title":"路由","keywords":"","body":"路由 Context概念 Context是iris框架中的一个路由上下文对象，在iris框架中的源码路径定义为：{$goPath}\\github.com\\kataras\\iris\\context\\context.go。以下是Context的声明和定义： package context type Context interface { BeginRequest(http.ResponseWriter, *http.Request) EndRequest() ResponseWriter() ResponseWriter ResetResponseWriter(ResponseWriter) Request() *http.Request SetCurrentRouteName(currentRouteName string) GetCurrentRoute() RouteReadOnly Do(Handlers) AddHandler(...Handler) SetHandlers(Handlers) Handlers() Handlers HandlerIndex(n int) (currentIndex int) Proceed(Handler) bool HandlerName() string Next() NextOr(handlers ...Handler) bool NextOrNotFound() bool NextHandler() Handler Skip() StopExecution() IsStopped() bool Params() *RequestParams Values() *memstore.Store Translate(format string, args ...interface{}) string Method() string Path() string RequestPath(escape bool) string Host() string Subdomain() (subdomain string) IsWWW() bool RemoteAddr() string GetHeader(name string) string IsAjax() bool IsMobile() bool Header(name string, value string) ContentType(cType string) GetContentType() string GetContentLength() int64 StatusCode(statusCode int) GetStatusCode() int Redirect(urlToRedirect string, statusHeader ...int) URLParamExists(name string) bool URLParamDefault(name string, def string) string URLParam(name string) string URLParamTrim(name string) string URLParamEscape(name string) string View(filename string, optionalViewModel ...interface{}) error Text(text string) (int, error) HTML(htmlContents string) (int, error) JSON(v interface{}, options ...JSON) (int, error) JSONP(v interface{}, options ...JSONP) (int, error) XML(v interface{}, options ...XML) (int, error) Markdown(markdownB []byte, options ...Markdown) (int, error) ...... 在该Context的接口定义中，我们可以发现，包含很多处理请求及数据返回的操作。在iris框架内，提供给开发者一个ContextPool，即存储上下文变量Context的管理池，该变量池中有多个context实例，可以进行复用。每次有新请求，就会获取一个新的context变量实例，来进行请求的路由处理。我们在实际的案例学习中，会向大家展示关于Context的相关用法。 正则表达式路由 Iris框架在进行处理http请求时，支持请求url中包含正则表达式。正则表达式的具体规则为： 1、使用{}对正则表达式进行包裹，url中出现类似{}样式的格式，即识别为正则表达式 2、支持自定义增则表达式的变量的命名，变量名用字母表示。比如：{name} 3、支持对自定义正则表达式变量的数据类型限制，变量名和对应的数据类型之间用“:”分隔开。比如：{name:string}表示增则表达式为name，类型限定为string类型 4、通过context.Params()的Get()和GetXxx()系列方法来获取对应的请求url中的增则表达式的变量 5、增则表达式支持变量的数据类型包括：string、int、uint、bool等 如下是正则表达式的请求示例： app.Get(\"/api/users/{isLogin:bool}\", func(context context.Context) { isLogin, err := context.Params().GetBool(\"isLogin\") if err != nil { context.StatusCode(iris.StatusNonAuthoritativeInfo) return } if isLogin { context.WriteString(\" 已登录 \") } else { context.WriteString(\" 未登录 \") } }) // http://localhost:8002?date=20190310&city=beijing //GET： http://localhost:8002/weather/2019-03-10/beijing // http://localhost:8002/weather/2019-03-11/beijing // http://localhost:8002/weather/2019-03-11/tianjin app.Get(\"/weather/{date}/{city}\", func(context context.Context) { path := context.Path() date := context.Params().Get(\"date\") city := context.Params().Get(\"city\") context.WriteString(path + \" , \" + date + \" , \" + city) }) 路由组的使用 在实际开发中，我们通常都是按照模块进行开发，同一模块的不同接口url往往是最后的一级url不同，具有相同的前缀url。因此，我们期望在后台开发中，可以按照模块来进行处理我们的请求，对于这种需求，iris框架也是支持的。 usersRouter := app.Party(\"/admin\", userMiddleware) 如上述代码所示，iris框架中使用app.Party方法来对请求进行分组处理，第二个参数是处理路由组的中间件方法，通常情况下我们会在中间件中写context.Next()方法。 app := iris.New() //用户模块users // xxx/users/register 注册 // xxx/users/login 登录 // xxx/users/info 获取用户信息 /** * 路由组请求 */ userParty := app.Party(\"/users\", func(context context.Context) { // 处理下一级请求 context.Next() }) /** * 路由组下面的下一级请求 * ../users/register */ userParty.Get(\"/register\", func(context context.Context) { app.Logger().Info(\"用户注册功能\") context.HTML(\"用户注册功能\") }) app.Run(iris.Addr(\":8003\"), iris.WithoutServerError(iris.ErrServerClosed)) 自定义路由中间件处理 定义路由中间件func userMiddleware(context iris.Context) { context.Next() } usersRouter := app.Party(\"/admin\", userMiddleware) //Done： usersRouter.Done(func(context context.Context) { context.Application().Logger().Infof(\"response sent to \" + context.Path()) }) usersRouter.Get(\"/info\", func(context context.Context) { context.HTML(\" 用户信息 \") context.Next()// 手动显示调用 }) usersRouter.Get(\"/query\", func(context context.Context) { context.HTML(\" 查询信息 \") }) app.Run(iris.Addr(\":8003\"), iris.WithoutServerError(iris.ErrServerClosed)) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"iris框架设置.html":{"url":"iris框架设置.html","title":"iris框架设置","keywords":"","body":"iris框架设置 应用程序内代码配置 在iris框架开发中，初始化应用程序时已经使用了默认的配置值。作为开发者，我们可以不需要其他额外的配置就启动我们的应用程序。 如果开发者想要自己根据自己的需求进行配置，iris框架也是支持的，本节课我们来学习一下iris框架所支持的配置方式。 现在主流的配置文件格式有：xml、yaml、 cnf、toml、json等等格式。xml现在使用的已经不多，cnf格式的配置文件适合数据库的配置文件，在本节内容中，我们将带大家学习多种配置文件的使用方法。 在iris程序的全局app实例中，支持通过多种方式进行代码配置，途径是多样的： 1、使用app.Configure(iris.WithConfiguration(iris.Configuration{DisableStartuplog:false}))来对整体应用进行配置项配置 2、通过app.Run方法的第二个参数来进行相关的自定义配置项的配置，第二个参数的类型同1一致。 以上两种方式，无论哪种方式，都是对app服务应用进行Configuration配置，提供应用配置的Configuration结构体定义所支持的配置项分别为： DisableInterruptHandler：如果设置为true，当人为中断程序执行时，则不会自动正常将服务器关闭。如果设置为true，需要自己自定义处理。默认为false。 DisablePathCorrection： 该配置项表示更正并将请求的路径重定向到已注册的路径。比如：如果请求/home/ 但找不到此Route的处理程序，然后路由器检查/home处理程序是否存在，如果是，（permant）将客户端重定向到正确的路径/home。默认为false。 EnablePathEscape：该配置选项用于配置是否支持路径转义。适用于请求url中包含转义字符时进行配置。默认为false。 FireMethodNotAllowed： 默认为false。 DisableBodyConsumptionOnUnmarshal：该设置选项用于配置读取请求数据的方法是否使用，如果设置为true，则表示禁用context.UnmarshalBody，context. ReadJSON以及context.ReadXML。默认为false。 DisableAutoFireStatusCode：该配置变量为控制是否处理错误自动执行，如果为true，则不会进行错误自动执行。该配置项默认为false。 TimeFormat：时间格式。默认格式为：\"Mon, 02 Jan 2006 15:04:05 GMT\" Charset：字体格式选项。默认字体为：\"UTF-8\" 通过TOML配置文件进行配置 什么是toml?toml是Tom’s Obvious, Minimal Language的缩写， toml是一种配置文件。TOML是前GitHub CEO， Tom Preston-Werner，于2013年创建的语言，其目标是成为一个小规模的易于使用的语义化配置文件格式。TOML被设计为可以无二义性的转换为一个哈希表(Hash table)。 具体的项目配置使用中，我们需要创建config.tml类型的配置文件，并在程序中明确使用toml文件进行读取配置内容。如下图所所示： app.Configure(iris.WithConfiguration(iris.TOML(\"./configs/iris.tml\"))) 通过YAML配置文件 YAML 是专门用来写配置文件的语言，写法简洁、功能强大，比JSON格式还要方便。Yaml实质上是一种通用的数据串行化格式。Yaml的主要语法格式有以下几项： 大小写敏感。 使用缩进表示层级关系。 缩进时不允许使用Tab键，只允许使用空格。 缩进的空格数目不受限制，相同层级的配置元素 左侧对齐即可。 在本节内容中，我们可以通过yaml配置文件来对应用进行简单选项的的配置： app.Configure(iris.WithConfiguration(iris.)) 通过读取自定义配置文件 这里我们给大家演示如何使用json格式的配置文件来进行应用的配置，然后从应用程序中进行读取。 首先创建json格式的配置文件，并编写配置项，如下图： { \"appname\": \"IrisDemo\", \"port\": 8000 } 在应用程序内，编程实现对配置文件的读取和解析，如下图： file, _ := os.Open(\"/Users/hongweiyu/go/src/irisDemo/5-路由组及Iris配置/config.json\") defer file.Close() decoder := json.NewDecoder(file) conf := Coniguration{} err := decoder.Decode(&conf) if err != nil { fmt.Println(\"Error:\", err) } fmt.Println(conf.Port) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"mvc包使用.html":{"url":"mvc包使用.html","title":"mvc包使用","keywords":"","body":"mvc包使用 mvc.Application iris框架中的mvc包中提供了Application结构体定义。开发者可以通过注册自定义的controller来使用对应提供的API， 其中包含路由组router.Party,以此用来注册layout、middleware以及相应的handlers等。 iris.mvc特性 iris框架封装的mvc包，支持所有的http方法。比如，如果想要提供GET，那么控制器应该有一个名为Get（）的函数， 开发者可以定义多个方法函数在同一个Controller中提供。这里的Get、Post方法是指的直接和八种请求类型同名的方法， mvc模块会自动执行到Get()、Post()等八种对应的方法。如下所示： //自定义的控制器 type CustomController struct{} //注册自定义控制器处理请求 mvc.New(app).Handle(new(CustomController)) //自动处理基础的Http请求 //Url： http://localhost:8000 //Type：GET请求 func (cc *CustomController) Get() mvc.Result{ //todo return mvc.Response{ ContentType:\"text/html\", } } /** * Url：http://localhost:8000 * Type：POST **/ func (cc *CustomController) Post() mvc.Result{ //todo return mvc.Response{} } 根据请求类型和请求URL自动匹配处理方法 在iris框架中的mvc设计包中，设定了自定义的控制器以后，支持根据请求类型和对应的URL自动匹配对应的处理方法。具体案例如下： /** * url：http://localhost:8000/info * type：GET请求 **/ func (cc *CustomController) GetInfo() mvc.Result{ //todo } /** * url：http://localhost:8000/login * type：POST **/ func (cc *CustomController) PostLogin() mvc.Result{ //todo } 如上案例，当我们发起请求时，iris框架就能够自动匹配对应的控制器的处理方法。除了上述get和post两个方法之外，http请求的八种类型中的其他请求类型，也支持自动匹配。 BeforeActivation方法 在通过Configure和Handle进行了自定义Controller绑定以后，就可以使用自己自定义的Controller来进行自定义处理处理请求方法。开发者可以在BeforeActivation方法中来处理请求定义。如下所示，我们给出案例说明： func （m *CustomController） BeforeActivation(a mvc.BeforeActivation){ a.Handle(\"GET\",\"/users/info\",\"QueryInfo\") } //对应处理请求的方法 func (m *CustomController) QueryInfo() mvc.Result{ //todo } 使用mvc.Configure配置路由组和控制器 除了使用mvc.new(app)来构建mvc.Application结构体对象和Handle方法来配置处理请求的控制器外，iris框架还支持使用mvc.Configure来配置路由组和控制器的设置。具体使用方法如下： mvc.Configure(app.Party(\"/user\"), func(mvc *mvc.Application) { mvc.Handle(new(UserController)) }) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"session的使用和控制.html":{"url":"session的使用和控制.html","title":"session的使用和控制","keywords":"","body":"session的使用和控制 Session对象创建 在实际的程序开发中，iris框架中可以非常方便的创建一个新的session对象。如下所示，即是session的创建： ... sessionID := \"mySession\" //session的创建 sess := sessions.New(sessions.Config{ Cookie: sessionID, }) 支持的数据类型 在上文中，我们说过session支持的数据类型要比cookie多，我们来看一下iris框架中的session所支持存储的数据类型： //String：字符串类型 session.GetString() //Int：无符号整形 及系列相关单位的同类型 session.GetInt() //Boolean：布尔值类型 session.GetBoolean() //Float：单精度数值类型 及系列相关单位的同类型 session.GetFloat() //interface{}：接口 即任意数据结构类型 session.GetFlash() 上述代码块，即列出了iris框架中所支持存储的数据类型。我们在接下来的本节课程内容中，将会演示如何进行具体使用。 Session的存储和使用 app := iris.New() sessionID := \"mySession\" //1、创建session并进行使用 sess := sessions.New(sessions.Config{ Cookie: sessionID, }) /** * 用户登录功能 */ app.Post(\"/login\", func(context context.Context) { path := context.Path() app.Logger().Info(\" 请求Path：\", path) userName := context.PostValue(\"name\") passwd := context.PostValue(\"pwd\") if userName == \"davie\" && passwd == \"pwd123\" { session := sess.Start(context) //用户名 session.Set(USERNAME, userName) //登录状态 session.Set(ISLOGIN, true) context.WriteString(\"账户登录成功 \") } else { session := sess.Start(context) session.Set(ISLOGIN, false) context.WriteString(\"账户登录失败，请重新尝试\") } }) /** * 用户退出登录功能 */ app.Get(\"/logout\", func(context context.Context) { path := context.Path() app.Logger().Info(\" 退出登录 Path :\", path) session := sess.Start(context) //删除session session.Delete(ISLOGIN) session.Delete(USERNAME) context.WriteString(\"退出登录成功\") }) app.Get(\"/query\", func(context context.Context) { path := context.Path() app.Logger().Info(\" 查询信息 path :\", path) session := sess.Start(context) isLogin, err := session.GetBoolean(ISLOGIN) if err != nil { context.WriteString(\"账户未登录,请先登录 \") return } if isLogin { app.Logger().Info(\" 账户已登录 \") context.WriteString(\"账户已登录\") } else { app.Logger().Info(\" 账户未登录 \") context.WriteString(\"账户未登录\") } }) app.Run(iris.Addr(\":8009\"), iris.WithoutServerError(iris.ErrServerClosed)) Session与数据库结合使用 app := iris.New() db, err := boltdb.New(\"sessions.db\", 0600) if err != nil { panic(err.Error()) } //程序中断时，将数据库关闭 iris.RegisterOnInterrupt(func() { defer db.Close() }) //session和db绑定 sess.UseDatabase(db) app.Run(iris.Addr(\":8009\"), iris.WithoutServerError(iris.ErrServerClosed)) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"项目文件配置和项目初始化运行.html":{"url":"项目文件配置和项目初始化运行.html","title":"项目文件配置和项目初始化运行","keywords":"","body":"项目文件配置和项目初始化运行 conf配置文件读取配置信息 我们前面说过，使用config.json配置文件来进行项目的相关配置。在本节内容中，我们先做简单配置即可。包含两部分：config.json和读取配置的方法。如下所示： { \"app_name\": \"CmsProject\", \"port\": \"9000\", \"static_path\": \"/manage/static\", \"mode\": \"dev\" } 相应的，提供一个AppConfig结构体和InitConfig方法来读取配置数据： type AppConfig struct { AppName string `json:\"app_name\"` Port int StaticPath string `json:\"static_path\"` Mode string `json:\"mode\"` } 静态资源路径配置及模版文件配置 静态资源路径配置：在Iris框架中，提供专门的方法供开发者设置静态资源路径，因为只有设置了静态资源路径，才能在浏览器中直接访问，否则是无法访问的。iris设置静态资源路径的方法如下案例所示： app.StaticWeb(\"/manage/static\", \"./static\") 模版文件配置：Iris框架中还支持我们注册模版文件，比如如下案例所示： app.RegisterView(iris.HTML(\"./static\", \".html\")) 项目初始化运行 在进行完项目架构和上述的项目配置后，我们就可以启动我们的项目，查看项目效果。至此，项目创建和基础环境已经准备完毕，接下来的内容中，我们就主要聚焦视线项目功能。 package main import ( \"github.com/kataras/iris\" \"github.com/kataras/iris/context\" \"github.com/kataras/iris/mvc\" \"irisDemo/CmsProject/service\" \"irisDemo/CmsProject/controller\" \"irisDemo/CmsProject/datasource\" \"github.com/kataras/iris/sessions\" \"time\" \"irisDemo/CmsProject/config\" ) func main() { app := newApp() //应用App设置 configation(app) //路由设置 mvcHandle(app) config := config.InitConfig() addr := \":\" + config.Port app.Run( iris.Addr(addr), //在端口9000进行监听 iris.WithoutServerError(iris.ErrServerClosed), //无服务错误提示 iris.WithOptimizations, //对json数据序列化更快的配置 ) } //构建App func newApp() *iris.Application { app := iris.New() //设置日志级别 开发阶段为debug app.Logger().SetLevel(\"debug\") //注册静态资源 app.StaticWeb(\"/static\", \"./static\") app.StaticWeb(\"/manage/static\", \"./static\") //注册视图文件 app.RegisterView(iris.HTML(\"./static\", \".html\")) app.Get(\"/\", func(context context.Context) { context.View(\"index.html\") }) return app } /** * MVC 架构模式处理 */ func mvcHandle(app *iris.Application) { //启用session sessManager := sessions.New(sessions.Config{ Cookie: \"sessioncookie\", Expires: 24 * time.Hour, }) engine := datasource.NewMysqlEngine() //管理员模块功能 adminService := service.NewAdminService(engine) admin := mvc.New(app.Party(\"/admin\")) admin.Register( adminService, sessManager.Start, ) admin.Handle(new(controller.AdminController)) //用户功能模块 userService := service.NewUserService(engine) user := mvc.New(app.Party(\"/v1/users\")) user.Register( userService, sessManager.Start, ) user.Handle(new(controller.UserController)) //统计功能模块 statisService := service.NewStatisService(engine) statis := mvc.New(app.Party(\"/statis/{model}/{date}/\")) statis.Register( statisService, sessManager.Start, ) statis.Handle(new(controller.StatisController)) } /** * 项目设置 */ func configation(app *iris.Application) { //配置 字符编码 app.Configure(iris.WithConfiguration(iris.Configuration{ Charset: \"UTF-8\", })) //错误配置 //未发现错误 app.OnErrorCode(iris.StatusNotFound, func(context context.Context) { context.JSON(iris.Map{ \"errmsg\": iris.StatusNotFound, \"msg\": \" not found \", \"data\": iris.Map{}, }) }) app.OnErrorCode(iris.StatusInternalServerError, func(context context.Context) { context.JSON(iris.Map{ \"errmsg\": iris.StatusInternalServerError, \"msg\": \" interal error \", \"data\": iris.Map{}, }) }) } console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"xorm框架介绍.html":{"url":"xorm框架介绍.html","title":"xorm框架介绍","keywords":"","body":"xorm框架介绍 xorm框架介绍 xorm是一个简单而强大的Go语言ORM库. 通过它可以使数据库操作非常简便。 通过xorm框架，开发者可以方便的使用各种封装好的方法来代替原生的sql语句。这样就降低了我们开发者使用数据库的门槛。本节内容，我们将通过xorm相关知识的学习，来逐步掌握在代码中如何操作数据库。 读者也可以通过相关的学习文档进行xorm框架的学习，如下是xorm框架相关的学习文档： xorm的Github仓库地址：https://github.com/go-xorm/xorm xorm说明文档地址：http://xorm.io/docs 支持数据库驱动列表 同其他对象关系映射框架一样，xorm也支持连接、操作多种数据库，包括：mysql、mymysql、postgres、tidb、sqlite、mssql、oracle(测试）。具体的每一种数据库类型的驱动安装如下： Mysql: Mysql: github.com/go-sql-driver/mysql MyMysql: github.com/ziutek/mymysql/godrv Postgres: github.com/lib/pq Tidb: github.com/pingcap/tidb SQLite: github.com/mattn/go-sqlite3 MsSql: github.com/denisenkom/go-mssqldb MsSql: github.com/lunny/godbc Oracle: github.com/mattn/go-oci8 (试验性支持) xorm安装 go get github.com/go-xorm/xorm mysql连接示例 创建引擎 engine, err := xorm.NewEngine(driverName, dataSourceName) 如上通过xorm.NewEngine方法创建一个数据库操作引擎，该方法需要两个参数：driveName和dataSourceName。在mysql引擎连接中，两个参数如下： driverName := \"mysql\" dataSrouceName := \"用户名:密码@/数据库名称?charset=utf8\" 另外，需要格外注意一点，需要在使用数据库引擎创建的地方导入对应的数据库引擎驱动，比如本节内容中的mysql数据库，引擎导入语句如下： _ \"github.com/go-sql-driver/mysql\" mysql连接配置 设置自动同步结构体到数据库 xorm框架的engine数据库引擎，提供了engine.Sync()方法，允许开发者将自定义的结构体同步到数据库中。 随着xorm框架不断更新和迭代，在Sync方法的基础上，又提供了Sync2方法，用于将结构体同步更新到数据库中。Sync2方法主要的特性是： 自动检测和创建表 自动检测和新增表中的字段名 自动检测创建和删除索引 自动转换varchar字段类型到text字段类型 自动警告字段的默认值 err = engine.Sync2(new(model.Permission), new(model.City), new(model.Admin), new(model.AdminPermission), new(model.User)) 如上是Sync2方法的使用方法 其他设置 是否显示SQL语句（开发调试时使用） engine.ShowSQL(true) 设置数据库最大连接数 engine.SetMaxOpenConns(10) 设置最大空闲连接数量：默认是2 engine.SetMaxIdleConns(5) 代码如下 package main import ( \"fmt\" _ \"github.com/go-sql-driver/mysql\" //不能忘记导入 \"github.com/go-xorm/xorm\" \"github.com/go-xorm/core\" ) func main() { //1. 创建数据库引擎对象 engine, err := xorm.NewEngine(\"mysql\", \"root:yu271400@/elmcms?charset=utf8\") if err != nil { panic(err.Error()) } //2. 数据库引擎关闭 defer engine.Close() //数据库引擎设置 engine.ShowSQL(true) //设置显示SQL语句 engine.Logger().SetLevel(core.LOG_DEBUG) //设置日志级别 engine.SetMaxOpenConns(10) //设置最大连接数 //engine.SetMaxIdleConns(2) engine.Sync(new(Person)) //查询表的所有数据 session := engine.Table(\"user\") count, err := session.Count() if err != nil { panic(err.Error()) } fmt.Println(count) //使用原生sql语句进行查询 result, err := engine.Query(\"select * from user\") if err != nil { panic(err.Error()) } for key, value := range result { fmt.Println(key, value) } } type Person struct { Age int Name string } console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"xorm结构体映射规则和表操作.html":{"url":"xorm结构体映射规则和表操作.html","title":"xorm结构体映射规则和表操作","keywords":"","body":"xorm结构体映射规则和表操作 名称映射规则 名称映射规则主要负责结构体名称到表名和结构体field到表字段的名称映射。 在xorm框架中由core.IMapper接口的实现者来管理，xorm内置了三种IMapper实现：core.SnakeMapper,core.SameMapper和core.GonicMapper。 SnakeMapper：支持struct为驼峰式命名，表结构中为下划线命名之间的转换。该种规则为xorm默认的Maper； SameMapper：映射规则支持结构体名称和对应的表名称以及结构体field名称与对应的表字段名称相同的命名； GonicMapper：该映射规则和驼峰式命名类似，但是对于特定词支持性更好，比如ID将会翻译成id，而不是驼峰式的i_d。 默认的名称映射规则为SnakeMapper，如果开发者需要改变时，可以使用创建的数据库引擎对象进行如下设置： engine.SetMapper(core.SameMapper{}) 另外，可以设置表名和表字段分别为不同的映射规则： engine.SetTableMapper(core.SameMapper{}) engine.SetColumnMapper(core.SnakeMapper{}) 使用Tag的映射规则 如果所有的命名都是按照IMapper的映射来操作的，那当然是最理想的。但是如果碰到某个表名或者某个字段名跟映射规则不匹配时，我们就需要别的机制来改变。 xorm提供了如下几种方式来进行： 如果结构体拥有TableName() string的成员方法，那么此方法的返回值即是该结构体对应的数据库表名。 通过engine.Table()方法可以改变struct对应的数据库表的名称，通过sturct中field对应的Tag中使用xorm:\"'column_name'\"可以使该field对应的Column名称为指定名称。这里使用两个单引号将Column名称括起来是为了防止名称冲突，因为我们在Tag中还可以对这个Column进行更多的定义。如果名称不冲突的情况，单引号也可以不使用。 Column属性定义 我们在field对应的Tag中对Column的一些属性进行定义，用于对我们的项目中的数据库表字段进行设置和限定。定义的方法基本和我们写SQL定义表结构类似。如下所示： type User struct { Id int64 Name string `xorm:\"varchar(25) notnull unique 'usr_name'\"` } xorm中对数据类型有自己的定义，具体的Tag规则如下，另Tag中的关键字均不区分大小写： name 当前field对应的字段的名称 pk 是否是Primary Key name 当前field对应的字段的名称 pk 是否是Primary Key autoincr 是否是自增 [not ]null 或 notnull 是否可以为空 unique 是否是唯一 index 是否是索引 extends 应用于一个匿名成员结构体或者非匿名成员结构体之上 - 这个Field将不进行字段映射 -> Field将只写入到数据库而不从数据库读取 Field将只从数据库读取，而不写入到数据库 created Field将在Insert时自动赋值为当前时间 updated Field将在Insert或Update时自动赋值为当前时间 deleted Field将在Delete时设置为当前时间，并且当前记录不删除 version Field将会在insert时默认为1，每次更新自动加1 default 0或default(0) 设置默认值，紧跟的内容如果是Varchar等需要加上单引号 json 表示内容将先转成Json格式 字段映射规则 除了上述表名的映射规则和使用Tag对字段进行设置以外，基础的Go语言结构体数据类型也会对应到数据库表中的字段中，具体的一些数据类型对应规则如下： Go语言数据类型 xorm 中的类型 implemented Conversion Text int, int8, int16, int32, uint, uint8, uint16, uint32 Int int64, uint64 BigInt float32 Float float64 Double complex64, complex128 Varchar(64) []uint8 Blob array, slice, map except []uint8 Text bool Bool string Varchar(255) time.Time DateTime cascade struct BigInt struct Text Others Text 表基本操作 创建表：CreateTables(),参数为一个或多个空的对应Struct的指针。 判断表是否为空：IsTableEmpty() 判断表是否存在：IsTableExist() 删除表：DropTables()，参数为一个或多个空的对应Struct的指针或者表的名字。 基本和统计操作 查询和统计主要使用Get, Find, Count, Rows, Iterate这几个方法，以及条件查询Where。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"xorm表基本操作及高级操作.html":{"url":"xorm表基本操作及高级操作.html","title":"xorm表基本操作及高级操作","keywords":"","body":"xorm表基本操作及高级操作 表结构基本操作 对表结构的操作最常见的操作是查询和统计相关的方法，我们首先来看相关实现： 条件查询 Id值查询：参数接收主键字段的值。例如： var user User engine.Id(1).Get(&user) 以上Id方法的使用，相当于如下sql语句： select * from user where id = 1 如果数据库表结构是复合主键，则在使用Id时进行主键分别指定，比如以下案例： engine.Id(core.PK(1,\"davie\").Get(&user) 以上该句代码表示的即是查询多个复合主键的情况,core.PK中传入的参数顺序应该与结构体定义中的主键顺序一致，否则匹配会出错。对应的sql语句如下： select * from user where id = 1 and name = 'davie' Where条件查询 Where条件查询与Sql语句中的where条件查询功能一致。我们通过案例来查看Where的使用方法，如下所示：engine.Where(\" user_name = ? and pwd = ? \", 'davie', '123').Get(&admin) 如上xorm引擎操作即是如下sql语句的功能：select * from admin where user_name = 'davie' and pwd = '123' And条件查询 And条件查询功能与Where语句的使用方式类似相同，作为并列条件和约束条件进行结果查询。使用方式如下：engine.Id(1).And(\" user_name = ?\",'davie\").Get(&user) 以上的And方法并列查询就相当于如下的sql语句：select * from user where id = 1 and user_name = 'davie' Or条件查询 Or条件查询的意思是或者的意思，与编程语言中的 “ || ”功能相同，在查询时，如果有多个条件使用了Or语句，则对于同一条数据而言，只要符合其中一个条件，就会被查询出来。具体的使用方法和对应的sql语句如下：engine.Id(1).Or(\"user_name = ?\",'davie').Get(&user) 如上的Or操作语句对应如下sql语句：select * from user where id = 1 or user_name = davie Sql条件查询 除了上述Id、Where、And、Or等方法的使用外，xorm同样支持执行原生的sql语句，方便更愿意使用原生SQL语句的开发者。engine.SQL(\" select * from user where id = 1 nad user_name = 'davie') 排序条件查询 在数据库查询时，会涉及到查询结果的排序问题。常规操作支持两种排序：正排序和逆排序。 在xorm中的实现与sql语句中的两种排序方式基本相同，分别定义为Asc方法和Desc方法。或者使用OrderBy方法对自定义的排序的字段进行指定。 注意：上述三个方法的参数都是string类型，用于指定表格字段。 In多值范围查询 In方法的多值范围查询，是用于某个字段中的条件查询，该方法需要两个参数：第一个参数为指定查询的字段，第二个参数为字段多取值内容。我们同样给出如下案例：engine.In('user_name','davie','pony','jack').Find() Cols特定字段查询 Cols方法可以接受一个或者多个特点的表字段名称，用来表示限定于操作特定的表字段。依然通过案例来说明： engine.Cols(\"user_name\",\"status\").Find(&admins) //select user_name, status from admin 上述Cols操作表示的sql语句就是注释所对应的sql语句，表示从admin表中，查询特定的user_name, status两个字段，并将查询后的集合进行返回。 engine.Cols(\"user_name\",\"status\").Update(&admin) //update admin set user_name = admin.User_name and status = admin.Status 我们可以看到，除了Find方法外，还可以调用Update方法，这里即表示更新表结构中的某条数据，且仅仅对该条数据的user_name和status两个字段进行更新，这正是由Cols方法的参数限定的。 AllCols操作所有字段 除了上述的Cols指定一个或者多个字段以外，还可以通过AllCols方法来操作表所有字段，用法与Cols使用方法一致，我们不再赘述。 MustCols操作限定字段 MustCols意为操作必须对某些字段起作用，该方法的使用和Update方法相结合的情况较多。 增删改查操作 说了这么多条件查询的内容，我们还没有介绍基本的表记录的增删改查操作呢。如下我们一一进行介绍： 增加记录操作 增加一条记录可以使用Insert方法完成。该方法接收一个参数，用于传入实际我们要保存的数据对象的结构体对象类型。如下所示： var user ... engine.Insert(&user) Delete删除记录操作 删除数据使用Delete方法来进行操作，但是我们在删除的时候要知道删除具体哪一条数据，因此在Delete操作前，需要使用我们之前讲过的Id操作将数据进行定位查找出来，我们举例如下： user := new(User) count,err := engine.Id(id).Delete(user) 第一个返回值count表示删除的记录数，第二个参数为错误返回值，当删除失败时，err不为nil。 Update修改记录操作 我们已经讲过MustCols的操作是用来限定必须影响某些表字段的操作的；这里再次我们强调，我们通常和Update操作放在一起来修改数据，作数据的更新操作。 admin := new(Admin) admin.Status = \"1\" count,err := engine.Id(id).Update(user) 以上的Update方法是用来更新全部的数据记录，如果是限定更新某个或者某几个字段，可以和Cols结合使用。 查询记录操作 查询方法有两个，分为查询单条数据和查询多条数据。单条数据的查询使用Get方法、多条数据的查询使用Find方法。 Count表结构统计功能 在进行表数据查询时，我们时长需要统计数据的条数，比如数据一共多少条，用来做分页处理；再比如统计用户数量，也需要使用到计数功能。框架提供给我们Count方法来实现数据统计功能，如下是一个简单的案例： admin := new(Admin) count,err := engine.Count(admin) 事务处理 同其他数据库框架一样，xorm也是支持事物操作的。在有需要的批量操作数据时，事务的使用往往是必要的。在xorm中，事务操作和Session联系在一起。一共三个步骤，分别为：创建session对象，Begin表示事务开始执行，Commit表示提交事务。中间为具体的数据库操作。 创建事务 session := engine.NewSession() defer session.Close() 事务开始 err := session.Begin() //事务相关操作 事务提交 err = session.Commit() if err != nil{ panic(err.Error()) } 事务回滚 当在执行事务过程中遇到任何错误时，应该及时停止事务，将已经执行的进行回滚。回滚使用的方法是Rollback方法, 只是在执行出现错误时进行回滚操作。 ... if err != nil { session.Rollback() return } 中间的事务相关操作，与我们的正常的数据库操作相同，支持开发者根据自己需求进行多种操作。比如插入数据和更改输入： 事务插入数据 admin := Admin{Name: \"Davie\", Status: \"1\"} _, err = session.Insert(&admin) 事务修改数据 ```## xorm表基本操作及高级操作 ##### author：Davie ##### 版权所有：北京千锋互联科技有限公司 在上节内容中，我们介绍了xorm框架表结构的映射规则和表结构的操作。本节课，继续来深入学习表结构基本操作和高级查询的相关功能。 ### 表结构基本操作 对表结构的操作最常见的操作是查询和统计相关的方法，我们首先来看相关实现： * 条件查询 + Id值查询：参数接收主键字段的值。例如： ``` var user User engine.Id(1).Get(&user) ``` 以上Id方法的使用，相当于如下sql语句： ``` select * from user where id = 1 ``` 如果数据库表结构是复合主键，则在使用Id时进行主键分别指定，比如以下案例： ``` engine.Id(core.PK(1,\"davie\").Get(&user) ``` 以上该句代码表示的即是查询多个复合主键的情况,core.PK中传入的参数顺序应该与结构体定义中的主键顺序一致，否则匹配会出错。对应的sql语句如下： ``` select * from user where id = 1 and name = 'davie' ``` + Where条件查询 Where条件查询与Sql语句中的where条件查询功能一致。我们通过案例来查看Where的使用方法，如下所示： ``` engine.Where(\" user_name = ? and pwd = ? \", 'davie', '123').Get(&admin) ``` 如上xorm引擎操作即是如下sql语句的功能： ``` select * from admin where user_name = 'davie' and pwd = '123' ``` + And条件查询 And条件查询功能与Where语句的使用方式类似相同，作为并列条件和约束条件进行结果查询。使用方式如下： ``` engine.Id(1).And(\" user_name = ?\",'davie\").Get(&user) ``` 以上的And方法并列查询就相当于如下的sql语句： ``` select * from user where id = 1 and user_name = 'davie' ``` + Or条件查询 Or条件查询的意思是或者的意思，与编程语言中的 “ || ”功能相同，在查询时，如果有多个条件使用了Or语句，则对于同一条数据而言，只要符合其中一个条件，就会被查询出来。具体的使用方法和对应的sql语句如下： ``` engine.Id(1).Or(\"user_name = ?\",'davie').Get(&user) ``` 如上的Or操作语句对应如下sql语句： ``` select * from user where id = 1 or user_name = davie ``` + Sql条件查询 除了上述Id、Where、And、Or等方法的使用外，xorm同样支持执行原生的sql语句，方便更愿意使用原生SQL语句的开发者。 ``` engine.SQL(\" select * from user where id = 1 nad user_name = 'davie') ``` + 排序条件查询 在数据库查询时，会涉及到查询结果的排序问题。常规操作支持两种排序：**正排序**和**逆排序**。 在xorm中的实现与sql语句中的两种排序方式基本相同，分别定义为Asc方法和Desc方法。或者使用OrderBy方法对自定义的排序的字段进行指定。 注意：上述三个方法的参数都是string类型，用于指定表格字段。 + In多值范围查询 In方法的多值范围查询，是用于某个字段中的条件查询，该方法需要两个参数：第一个参数为指定查询的字段，第二个参数为字段多取值内容。我们同样给出如下案例： ``` engine.In('user_name','davie','pony','jack').Find() ``` + Cols特定字段查询 Cols方法可以接受一个或者多个特点的表字段名称，用来表示限定于操作特定的表字段。依然通过案例来说明： ``` engine.Cols(\"user_name\",\"status\").Find(&admins) //select user_name, status from admin ``` 上述Cols操作表示的sql语句就是注释所对应的sql语句，表示从admin表中，查询特定的user_name, status两个字段，并将查询后的集合进行返回。 ``` engine.Cols(\"user_name\",\"status\").Update(&admin) //update admin set user_name = admin.User_name and status = admin.Status ``` 我们可以看到，除了Find方法外，还可以调用Update方法，这里即表示更新表结构中的某条数据，且仅仅对该条数据的user_name和status两个字段进行更新，这正是由Cols方法的参数限定的。 + AllCols操作所有字段 除了上述的Cols指定一个或者多个字段以外，还可以通过AllCols方法来操作表所有字段，用法与Cols使用方法一致，我们不再赘述。 + MustCols操作限定字段 MustCols意为操作必须对某些字段起作用，该方法的使用和Update方法相结合的情况较多。 ### 增删改查操作 说了这么多条件查询的内容，我们还没有介绍基本的表记录的增删改查操作呢。如下我们一一进行介绍： * 增加记录操作 增加一条记录可以使用Insert方法完成。该方法接收一个参数，用于传入实际我们要保存的数据对象的结构体对象类型。如下所示： ``` var user ... engine.Insert(&user) ``` * Delete删除记录操作 删除数据使用Delete方法来进行操作，但是我们在删除的时候要知道删除具体哪一条数据，因此在Delete操作前，需要使用我们之前讲过的Id操作将数据进行定位查找出来，我们举例如下： ``` user := new(User) count,err := engine.Id(id).Delete(user) ``` 第一个返回值count表示删除的记录数，第二个参数为错误返回值，当删除失败时，err不为nil。 * Update修改记录操作 我们已经讲过MustCols的操作是用来限定必须影响某些表字段的操作的；这里再次我们强调，我们通常和Update操作放在一起来修改数据，作数据的更新操作。 ``` admin := new(Admin) admin.Status = \"1\" count,err := engine.Id(id).Update(user) ``` 以上的Update方法是用来更新全部的数据记录，如果是限定更新某个或者某几个字段，可以和Cols结合使用。 * 查询记录操作 查询方法有两个，分为查询单条数据和查询多条数据。单条数据的查询使用Get方法、多条数据的查询使用Find方法。 ### Count表结构统计功能 在进行表数据查询时，我们时长需要统计数据的条数，比如数据一共多少条，用来做分页处理；再比如统计用户数量，也需要使用到计数功能。框架提供给我们Count方法来实现数据统计功能，如下是一个简单的案例： ``` admin := new(Admin) count,err := engine.Count(admin) ``` ### 事务处理 同其他数据库框架一样，xorm也是支持事物操作的。在有需要的批量操作数据时，事务的使用往往是必要的。在xorm中，事务操作和Session联系在一起。一共三个步骤，分别为：创建session对象，Begin表示事务开始执行，Commit表示提交事务。中间为具体的数据库操作。 ###### 创建事务 ``` session := engine.NewSession() defer session.Close() ``` ###### 事务开始 ``` err := session.Begin() //事务相关操作 ``` ###### 事务提交 ``` err = session.Commit() if err != nil{ panic(err.Error()) } ``` ###### 事务回滚 当在执行事务过程中遇到任何错误时，应该及时停止事务，将已经执行的进行回滚。回滚使用的方法是Rollback方法, 只是在执行出现错误时进行回滚操作。 ``` ... if err != nil { session.Rollback() return } ``` 中间的事务相关操作，与我们的正常的数据库操作相同，支持开发者根据自己需求进行多种操作。比如插入数据和更改输入： * 事务插入数据 ``` admin := Adm admin := Admin{ Name:\"Davie\"} count,err := session.Id(2).Update(&admin) if err != nil { seesion.Rollback() return } ``` 代码如下: package main import ( \"github.com/go-xorm/xorm\" \"github.com/go-xorm/core\" \"fmt\" _ \"github.com/go-sql-driver/mysql\" ) /** * xorm基本操作和高级操作 */ func main() { //1. 创建数据库引擎对象 engine, err := xorm.NewEngine(\"mysql\", \"root:yu271400@/testCms?charset=utf8\") if err != nil { panic(err.Error()) } //2.设置映射规则 engine.SetMapper(core.SnakeMapper{}) //3、同步数据库表格 engine.Sync2(new(PersonTable)) //4.判断person表格是否存在 personExist, err := engine.IsTableExist(new(PersonTable)) if err != nil { panic(err.Error()) } if personExist { fmt.Println(\"人员表存在\") } else { fmt.Println(\"人员表不存在\") } //5.判断person表格是否为空 personEmpty, err := engine.IsTableEmpty(new(PersonTable)) if err != nil { panic(err.Error()) } if personEmpty { fmt.Println(\" 人员表是空的 \") } else { fmt.Println(\" 人员表不为空 \") } //二、条件查询 //1.ID查询 var person PersonTable // select * from person_table where id = 1 engine.Id(1).Get(&person) fmt.Println(person.PersonName) fmt.Println() //2.where多条件查询 var person1 PersonTable // select * from person_table where person_age = 26 and person_sex = 2 engine.Where(\" person_age = ? and person_sex = ?\", 26, 2).Get(&person1) fmt.Println(person1.PersonName) fmt.Println() //3.And条件查询 var persons []PersonTable //select * from person_table where person_age = 26 and person_sex = 2 err = engine.Where(\" person_age = ? \", 26).And(\"person_sex = ? \", 2).Find(&persons) if err != nil { panic(err.Error()) } fmt.Println(persons) fmt.Println() //4、Or条件查询 var personArr []PersonTable //select * from person_table where person_age = 26 or person_sex = 1 err = engine.Where(\" person_age = ? \", 26).Or(\"person_sex = ? \", 1).Find(&personArr) if err != nil { panic(err.Error()) } fmt.Println(personArr) fmt.Println() //5、原生SQL语句查询支持 like语法 var personsNative []PersonTable err = engine.SQL(\" select * from person_table where person_name like 't%' \").Find(&personsNative) if err != nil { panic(err.Error()) } fmt.Println(personsNative) fmt.Println() //6、排序条件查询 var personsOrderBy []PersonTable //select * from person_table orderby person_age 升序排列 //engine.OrderBy(\" person_age \").Find(&personsOrderBy) engine.OrderBy(\" person_age desc \").Find(&personsOrderBy) fmt.Println(personsOrderBy) fmt.Println() //7、查询特定字段 var personsCols []PersonTable engine.Cols(\"person_name\", \"person_age\").Find(&personsCols) for _, col := range personsCols { fmt.Println(col) } //三、增加记录操作 personInsert := PersonTable{ PersonName: \"Hello\", PersonAge: 18, PersonSex: 1, } //rowNum, err := engine.Insert(&personInsert) //fmt.Println(rowNum) //rowNum 受影响的记录条数 //fmt.Println() //四、删除操作 rowNum, err := engine.Delete(&personInsert) fmt.Println(rowNum) //rowNum 受影响的记录条数 fmt.Println() //五、更新操作 rowNum, err = engine.Id(7).Update(&personInsert) fmt.Println(rowNum) //rowNum 受影响的记录条数 fmt.Println() //六、统计功能count count, err := engine.Count(new(PersonTable)) fmt.Println(\"PersonTable表总记录条数：\", count) //七、事务操作 personsArray := []PersonTable{ PersonTable{ PersonName: \"Jack\", PersonAge: 28, PersonSex: 1, }, PersonTable{ PersonName: \"Mali\", PersonAge: 28, PersonSex: 1, }, PersonTable{ PersonName: \"Ruby\", PersonAge: 28, PersonSex: 1, }, } session := engine.NewSession() session.Begin() for i := 0; i console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"}}